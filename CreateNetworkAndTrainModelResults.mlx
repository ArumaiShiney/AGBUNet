ABOVE GROUND MASS ESTIMATION USING SATELLITE IMAGERY
** Purpose: The purpose of this project is to estimate the above ground mass of finland using the available satellite images from Sentinel-1 S1, Sentinel-2 S2 and AGBM images**

inputPath = 's3://drivendata-competition-biomassters-public-us/';
Importing and Pre-processing the Data
For data pre-processing, 3 sets of images from S1, S2 and AGBM are considered. S1 and S2 images are taken for each month and mapped with 1 AGBM image using the chip-ID. 
Below is the snapshot of the dataset summary:
AGBM - 8689
S1 - 104268
S2 - 84810
agbmFolderPath = fullfile(inputPath, 'train_agbm');
Input data
imageInput = imageDatastore(agbmFolderPath, 'ReadFcn', @(filename)mapS1S2Datawithagbm(filename, inputPath), 'LabelSource', 'foldernames');
  [inputTrain,inputVal] = splitEachLabel(imageInput,0.15,0.05);

Output data
imageOutput = imageDatastore(agbmFolderPath, 'LabelSource', 'foldernames');
 [outputTrain,outputVal] = splitEachLabel(imageOutput,0.15,0.05);

Combining inputs and labels for training
dsTrain = combine(inputTrain, outputTrain);
dsVal = combine(inputVal, outputVal);

sampleInputOutput = preview(dsTrain);
montage(rescale(sampleInputOutput{1})); % Input Data
colormap("turbo");
imshow(rescale(sampleInputOutput{2})); % Output Data
colormap("turbo");
lgraph = unetLayers([256 256 15], 2,'encoderDepth',2); %% Encoding layer is updated as 4. Hence number of layers will show as 57
lgraph = lgraph.removeLayers('Softmax-Layer');
lgraph = lgraph.removeLayers('Segmentation-Layer');
%finalConvolutionLayer = convolution1dLayer(3, 4, 'Name', 'Final-ConvolutionLayer-1D' ,Padding="causal");
finalConvolutionLayer = convolution2dLayer([3, 4], 1, 'Name', 'Final-ConvolutionLayer-2D',Padding="same");
lgraph = lgraph.replaceLayer('Final-ConvolutionLayer', finalConvolutionLayer);
lgraph = lgraph.addLayers(regressionLayer('name','regressionLayer'));
lgraph_1 = lgraph.connectLayers('Final-ConvolutionLayer-2D','regressionLayer');
deepNetworkDesigner(lgraph_1)
analyzeNetwork(lgraph_1);



Using the pre-trained model or training the model
% If you want to train the model from scratch, change "train_network"
% value. The concept of minibatch can be added later 

train_network = false; % to true.
if train_network
    options = trainingOptions('adam', ...
             'InitialLearnRate', .0001, ...
             'MiniBatchSize', 10, ...
              'MaxEpochs', 1, ...
              'ValidationData', dsVal, ...
              'OutputNetwork', 'best-validation-loss', ...
              'Verbose', true, ...
           	'Plots','training-progress');
    net = trainNetwork(dsTrain,lgraph_1,options);
     save('trainedNetwork_unet.mat','net') %% will save the trained model in Matlab Drive
else
    lgraph_1 = load('trainedNetwork_unet.mat');% Load pre-trained network from Matlab Drive. 
    net = lgraph_1.net;
end

Calculating RMSE of validation data
Note: If the predict(net,input_label{1}) is changed to predict(net,dsVal), code is throwing error. Need to understand why it is throwing error
for ii=1:size(dsVal.UnderlyingDatastores{2,1}.Files,1)
    input_label = dsVal.read; % reading input and label
     Y_Val{ii} = predict(net,input_label{1}); % Predicting labels
    testBatch{ii} = input_label{2};
end
for idx = 1:size(Y_Val, 2)
    predicted = Y_Val{idx};
    ref = testBatch{idx};
    rmse_mat{idx} = sqrt(mse(ref, predicted));

       rescaledPred = rescale(predicted);
        rescaledRef = rescale(ref);
         title('Expected vs Actual');
        montage({rescaledRef,rescaledPred})
        colormap("jet")
        figure
       
end
% Error of predicting validation data (rmse)

mean([rmse_mat{:}])


%% Reading training and testing data features
featuresMetadataLocation = fullfile('features_metadata_sample.csv');
featuresMetadata = readtable(featuresMetadataLocation, 'ReadVariableNames',true);

testFeatures = featuresMetadata(strcmp(featuresMetadata.split, 'test'), :);
trainFeatures = featuresMetadata(strcmp(featuresMetadata.split, 'train'), :);
testChips = testFeatures.chip_id;
trainChips = trainFeatures.chip_id;
[~, uniqueIdx_train, ~] = unique(trainChips);
[~, uniqueIdx_test, ~] = unique(testChips);
uniqueTestChips = testChips(uniqueIdx_test, :);
uniqueTrainChips = trainChips(uniqueIdx_train, :);

%% Creating a folder to save predictions of the 1-D CNN

if ~exist('predictions_1D', 'dir')
    mkdir predictions_1D
end
outputFolder = './predictions_1D/';

% If you want to produce data for unet network the "train_data" value should be true.
% Change it to false if you just want to predict testing data
train_data = false; 

if train_data
uniqueChips =  [uniqueTrainChips(:)' uniqueTestChips(:)'];
else
    uniqueChips =  uniqueTestChips;
end

for chipIDNum = 1:length(uniqueChips)
    
    chip_id = uniqueChips{chipIDNum};
 
    % Format inputs
    if (chipIDNum <= length(uniqueTrainChips)) &&  (train_data)
        inputImage = readTestingSatelliteData(chip_id, agbmFolderPath, true);% reading train data
    else
        inputImage = readTestingSatelliteData(chip_id, agbmFolderPath, false);% reading test data
    end
   % X_test = gpuArray(dlarray(single(inputImage),"CBT"));
    % Make predictions
    pred_temp = predict(net, inputImage);
    pred = rescale(pred_temp);
    montage(pred);
   % pred = extractdata(pred);
    % Set up TIF file and export prediction
    filename = [outputFolder, chip_id, '_agbm.tif'];
    t = Tiff(filename, 'w');
    
    % Need to set tag info of Tiff file
    tagstruct.ImageLength = 256; 
    tagstruct.ImageWidth = 256;
    tagstruct.Photometric = Tiff.Photometric.MinIsBlack;
    tagstruct.BitsPerSample = 32;
    tagstruct.SamplesPerPixel = 1;
    tagstruct.SampleFormat = Tiff.SampleFormat.IEEEFP;
    tagstruct.PlanarConfiguration = Tiff.PlanarConfiguration.Chunky; 
    tagstruct.Compression = Tiff.Compression.None;
    tagstruct.Software = 'MATLAB'; 
    setTag(t,tagstruct)
 
    % Export your prediction
    write(t, pred);
    close(t);
    
    disp (filename) , imread(filename);
     
        colormap("colorcube")
end



Supporting functions
% This supporting function reads the input data and prepares them for training the network.



function avgImS1S2 = mapS1S2Datawithagbm(outputFilename, inputPath)
    outputFilenameParts = split(outputFilename, ["_", "\"]);
    chip_id = outputFilenameParts{end-1};

    inputDir = fullfile(inputPath, 'train_features\');
    correspondingFiles = dir([inputDir, chip_id, '*.tif']);
    
    % The satellite images range from 00-11, so preallocate a cell arrray
    s1Data = cell(1, 12);
    s2Data = cell(1, 12);

    % Compile and order all data
    for fileIdx = 1:length(correspondingFiles)
        filename = correspondingFiles(fileIdx).name;
        filenameParts = split(filename, ["_", "\", "."]);
        satellite = filenameParts{end-2};

        fullfilename = strcat(inputDir, filename);
        im = imread(fullfilename);

        % Plus one because matlab starts at 1
        idx = str2double(filenameParts{end-1}) + 1;

        % Add all input images to ordered cell array
        if satellite == 'S1'
            s1Data{idx} = im;
        elseif satellite == 'S2'
            s2Data{idx} = im;
        end
    end

    % Ignore missing data
    for imgNum = 1:12
        % Not enough bands
        if size(s1Data{imgNum}, 3) ~= 4
            s1Data{imgNum} = [];
        elseif size(s2Data{imgNum}, 3) ~= 11
            s2Data{imgNum} = [];
        end

        % Value of -9999
        if ismember(-9999, s1Data{imgNum})
            s1Data{imgNum} = [];
        elseif ismember(-9999, s2Data{imgNum})
            s2Data{imgNum} = [];
        end
    end

    % Calculate average S1 data
    totalImS1 = zeros(256, 256, 4);
    for imgNum1 = 1:length(s1Data)
        currIm = s1Data{imgNum1};
        if ~(isempty(currIm))
            totalImS1 = totalImS1 + currIm;
        end
    end
    avgImS1 = totalImS1 ./ length(s1Data);

    % Calculate average S2 data
    totalImS2 = zeros(256, 256, 11);
    for imgNum2 = 1:length(s2Data)
        currIm = s2Data{imgNum2};
        if ~(isempty(currIm))
            totalImS2 = totalImS2 + currIm;
        end
    end
    avgImS2 = totalImS2 ./ length(s2Data);

    % Combine all bands into one 15 band image
    avgImS1S2 = cat(3, avgImS1, avgImS2);

    % Rescale so the values are between 0 and 1
    avgImS1S2 = rescale(avgImS1S2);
end


function avgImS1S2 = readTestingSatelliteData(chip_id, s3Path, train_data)
   if train_data
    inputDir = fullfile(s3Path, 'train_features/');
else
    inputDir = fullfile(s3Path, 'test_features/');
end
    correspondingFiles = dir([inputDir, chip_id, '*.tif']);
    
    % The satellite images range from 00-11, so preallocate a cell arrray
    s1Data = cell(1, 12);
    s2Data = cell(1, 12);
	S1Data_mat = zeros(12,256,256,4);
	S2Data_mat = zeros(12,256,256,11);

    % Compile and order all data
    for fileIdx = 1:length(correspondingFiles)
        filename = correspondingFiles(fileIdx).name;
        filenameParts = split(filename, ["_", "\", "."]);
        satellite = filenameParts{end-2};

        fullfilename = strcat(inputDir, filename);
        im = imread(fullfilename);

        % Plus one because matlab starts at 1
        idx = str2double(filenameParts{end-1}) + 1;

        % Add all input images to ordered cell array
        if satellite == 'S1'
            s1Data{idx} = im;
			% S1Data_mat(idx,:,:,:)=im;
        elseif satellite == 'S2'
            s2Data{idx} = im;
			% S2Data_mat(idx,:,:,:)=im;
        end
    end

    % Ignore missing data
    for imgNum = 1:12
        % Not enough bands
        if size(s1Data{imgNum}, 3) ~= 4
            s1Data{imgNum} = [];
        elseif size(s2Data{imgNum}, 3) ~= 11
            s2Data{imgNum} = [];
        end

        % Value of -9999
        if ismember(-9999, s1Data{imgNum})
            s1Data{imgNum} = [];
        elseif ismember(-9999, s2Data{imgNum})
            s2Data{imgNum} = [];
        end
    end

    % Calculate average S1 data
    totalImS1 = zeros(256, 256, 4);
    for imgNum1 = 1:length(s1Data)
        currIm = s1Data{imgNum1};
        if ~(isempty(currIm))
            totalImS1 = totalImS1 + currIm;
        end
    end
    avgImS1 = totalImS1 ./ length(s1Data);

    % Calculate average S2 data
    totalImS2 = zeros(256, 256, 11);
    for imgNum2 = 1:length(s2Data)
        currIm = s2Data{imgNum2};
        if ~(isempty(currIm))
            totalImS2 = totalImS2 + currIm;
        end
    end
    avgImS2 = totalImS2 ./ length(s2Data);

    % Combine all bands into one 15 band image
    avgImS1S2 = cat(3, avgImS1, avgImS2);

    % Rescale so the values are between 0 and 1
    avgImS1S2 = rescale(avgImS1S2);
	
end
